
-- V7


-- User-friendly settings:




--      1. Select AI type on your craft:
--                        '1' for Standard/Hybrid AI. Will take control from AI.
--                        '2' for Breadboard AI. Will send commands via complex controls.
--                        '3' use both for whatever unholy reasons.
            TypeOfAiOnTheCraft = 1


--      2. Run integration test and don't forget to set this to 0 after:
--                        Set this to some time in seconds to run integration test. 10 seconds will do.
--                        Set this to '0' to disable it afterwards.
            IntegrationTestDuration = 0





--  The end of user-friendly settings! 







--  Dimensions and margins
            MaximumSizeOfEnemyShips = 300
            MaximumSizeOfEnemyPlanes = 100
            MaximumSizeOfEnemySubmarines = 100
            MaximumSizeOfEnemyLandUnits = 50

            SafeDistanceForShips = 350
            SafeDistanceForPlanes = 100
            SafeDistanceForSubmarines = 200
            SafeDistanceForLandUnits = 100

            ExtraDistanceForBeingFriendly = 25
            
            MaximumTimeForCoursePrediction = 15
            ObstacleExclusionDistance = 1000                -- Only crafts closer than this will be considered for possible collision.


-- Map and terrain
            DoAvoidMapBorders = true               -- Set this to 'true' if your craft will be fighting on a map with limited area. 
                                                    -- Map will be scanned to find its borders, where terrain ends with the sharp drop to the seabed level.
                                                    -- This feature intended for Arena-style maps.
            MinimumDistanceFromBorder = 500
            TimeToPredictBorderViolation = 5

            ProbeAheadForTerrain = false             -- 'true' for you craft to bounce away from walls on arena or from slopes of regular terrain. 'false' to disable.
            TimeToPredictTerrain = 10
            AltitudeDifferenceToPanic = -30         -- Craft will turn away if the difference between CoM and terrain ahead are this big.
                                                    -- E.g. >0 - hill/wall for tanks, <0 - safe depth for ship.
            ProbeForTerrainIfPlane = true
            SendPitchUpIfTerrainAhead = true         -- In addition to turning left/right, will try to go up if 'true'. 'false' to disable.
            
            MinimumTerrainAltitudeToBeLandMap = -10     -- If altitude around center of the map is more than this - map will be treated as "Land map"
                                                        --      and everything that is too low for "Plane" and too high for "Submarine"
                                                        --      will be treated as "Land Unit", instead of being "Ship".


--  Definition for Classes
            AltitudeToBePlane = 20                -- Altitude (above average height of map center) at which crafts will be treated as planes.
            
            AltitudeToBeSubmarine = -11           -- Altitude at which crafts will be treated as submarines.
            
            TypeOfTheCraft = 1                    -- Type of the craft. Default - '1'.
                                                  -- '1' for Automatic/Universal. Appropriate class will chosen based on current altitude.
                                                  -- '2' for Surface: Ships, Water skimmers, Land units, etc.
                                                  -- '3' for Planes.                
                                                  -- '4' for Submarines.    


-- Class segregation rules:
            ShouldYourPlaneAvoidSurfaceCrafts = false
            ShouldYourSurfaceCraftAvoidPlanes = false
            ShouldYourSurfaceCraftAvoidSubmarines = false
            ShouldYourSubmarineAvoidSurfaceCrafts = true
            
            DoCheckForCollisionWithEnemy = true             --  Leave this as 'true', unless you are building melee craft
            DoCheckForCollisionWithFriendlies = true        --  or hate your own fleet
            


-- "Gant" algorithm tuning (by default it will be used on Planes and Submarines):
            DisableUpAndDownCourseChange = false    -- If set to 'true' - craft will not change its altitude to avoid collision.
            
            UsePitchAltitudeLimit = true            -- If set to 'true' - craft will not change its altitude to avoid collision, 
                                                    --      if its altitude will be predicted outside of set safe limits.
            
            MinimumAltitudeForPlanePitchDown = 200
            MaximumAltitudeForPlanePitchUp = 350
            
            MinimumAltitudeForSubmarinePitchDown = -200
            MaximumAltitudeForSubmarinePitchUp = -100
            
            DownwardsSafetyFactor = 0.5             -- Multipliers for perceived safety for maneuvers. Set to '1' for fair assessment.
            LeftSafetyFactor = 0.95


--  Delays, in frames (1/40 of a second)
            DelayBeforeTakingControlFromStandardAI = 10  -- To prevent small corrections to interfere with standard AI.
            StartupDelay = 0         -- Increase it if you need more control after spawn.             


--  Values for control axies, useful for standard AI
            PropulsionRequestWhileAvoiding = 1
            PropulsionRequestToStopOrReverse = 0.1
            PropulsionRequestForYawRight = -1               -- Set this to '0' to disable the use of the control axis. 
            PropulsionRequestForPitchUp = 1                 -- Will not be overridden by roll-remap!

            ChangeToYawDirectionWhileInReverse = 1              -- Set to -1 to invert yaw. Using reverse are not recommended!
            MinimumDistanceToKeepReversing = 200                -- You craft will continue to reverse until it get this far from obstacle. 

--  Meaning of complex controls for commands, used for breadboard
            CCCForYawRight = 8       -- K
            CCCForYawLeft = 4        -- H
            
            CCCForPitchUp = 10       -- L
            CCCForPitchDown = 9      -- O

            CCCWhileAvoiding = 5     -- U
            CCCToStopOrReverse = 6   -- J

-- "Don't mess with" section (and i mean it!)
            ActiveCraftsPerFrame = 3        -- This must be the same for all crafts in your fleet!
                                            -- Defines how many instances of the script can be active on the crafts in your fleet during each frame.

            ShowMessageForRunningAndWarnings = false

            CourseChangeDegreesToLookForSafety = 30
            
            ForceUsageOfAlgorithm = "Auto"      --  'Auto' - Based on current class.
                                                --  'Big Boy' - will use recorded turn rate to predict movement of obstacles.
                                                --      Expensive, but capable of preventing pile-ups.
                                                --      Intended for big ships and other not too wobbly or too pitchy crafts.
                                                --  'Gnat' - will prob at the sides for less dangerous position, assuming instant turn.
                                                --      Cheap, but good enough for maneuverable crafts.
            AlgorithmForShip = "Big Boy"
            AlgorithmForPlane = "Gnat"
            AlgorithmForSubmarine = "Gnat"
            AlgorithmForLandUnit = "Big Boy"
















--[[




First shalt thou set type of AI, be that bread or standard.
Then, shalt thou do no more, but do no less.
Setting of the type shalt be the change thou shalt do,
 and the only change to the script shall be setting of the AI type.
Any functions shalt thou not change, nor either unknown variables,
 excepting that thou set the AI type.
Any change to the any function is right out.
Once the type of AI, being in the beginning of the script, be set,
 then all changes shall be ceased and no naughty collisions thou shalt suffer.
 
 



]]













--                                      Don't touch the rest!













CounterForDelayBeforeTakingControlFromStandardAI = 0

FrameCounter = 0
LastActiveFrame = 0
NumberOfSkippedFrames = 1

PreferredRight = true
AggressiveForward = true

--MaximumRateOfRotation = 25
--MinimumRateOfRotation = 1

--YawCommandMultiplier = 1
--TryToOversaturateControlAxies = false


DoInitializationOnStart = true

ConstructDimensions = Vector3(1, 1, 1)
ConstructSphericalHalfSize = 0

FallBackForEnemySphericalHalfSize = MaximumSizeOfEnemyShips / 2
DimensionsOfFriendlies = {}
DimensionsOfEnemies = {}
ConstantForConstructId = -99
ConstantForEnemyId = -77

LastFrameConstructVelocity = Vector3(0, 0, 0)
LastFrameConstructPosition = Vector3(0, 10000, 0)
ConstructCurrentSpeed = 10
ConstructCurrentCourse = 0
ConstructMaxTurnRate = 10
TimeNeededForConstructToReactSafely = 3
LastFramePositionsAndVectors = {}
RateOfRotationAndSpeed = {}
DeclineOfRateOfRotation = 0.999        -- Redo
DeclineOfSpeed = 0.9992
EmaNumber = 0.1
EmaNumberForConstructSpeed = 0.1
EmaNumberForCourse = 0.15           -- As function of speed or something !!!
EmaNumberForMaxCourse = 0.01
EmaNumberForTurnRate = 0.1
ConstantForBigNumber = 999999

ConstantForFramesPerSecond = 40

NumberOfFramesToPredictWith = 10

ConstructForwardsVelocityMagnitude = 0

ConstructHealthFractionWhenMaxSpeed = 1
ConstructHealthFractionWhenMaxTurnRate = 1
ConstructMaxSpeed = 0
ChangeInConstructHealthBeforeEvaluation = 0.98

ConstructMaxTurnRateLongAverage = 0

PreviousCountForEnemiesAndFriendlies = 0
PreviousCountForFriendlies = 0
ConstructPriorityNumber = 0

DesiredYaw = 0
DesiredForward = 0
DesiredPitch = 0

CounterForPollDelay = -99
PollResultForPreviousFrame = 0
VictoryInThePoll = false
VictoryInThePollForPreviousFrame = false


MapBorderPointX1 = -10000
MapBorderPointZ1 = 10000
MapBorderPointX2 = 10000
MapBorderPointZ2 = -10000

HasTheWorldMovedOn = false

CurrentSafeDistance = SafeDistanceForShips
CurrentTypeOfTheCraft = TypeOfTheCraft
HeightOfMapCenter = 0
IsItALandMap = false

CurrentAlgorithm = "Gnat"

function UpdateRotationAndSpeed(constructVelocity, newPositionsAndVectors)                             -- Need fix for angle at low speed?
    local constructHealthFraction = I:GetHealthFraction()
    
    if constructVelocity.magnitude < 5 or (constructVelocity-LastFrameConstructVelocity).magnitude < 1 then
        constructVelocity = LastFrameConstructVelocity
    end

    if constructVelocity.magnitude >= ConstructMaxSpeed then
        ConstructMaxSpeed = ConstructMaxSpeed * (1 - EmaNumberForConstructSpeed) + constructVelocity.magnitude * EmaNumberForConstructSpeed
        ConstructHealthFractionWhenMaxSpeed = constructHealthFraction
    elseif constructHealthFraction <= ConstructHealthFractionWhenMaxSpeed * ChangeInConstructHealthBeforeEvaluation then
        ConstructMaxSpeed = ConstructMaxSpeed - ConstructMaxSpeed * constructHealthFraction / ConstructHealthFractionWhenMaxSpeed / ConstantForFramesPerSecond * NumberOfSkippedFrames / 10
    end    
    
    ConstructCurrentSpeed = math.max(1, ConstructCurrentSpeed * (1 - EmaNumber) + constructVelocity.magnitude * EmaNumber)            -- Reverse ??
    
    local constructTurnRate = Vector3.SignedAngle(constructVelocity, LastFrameConstructVelocity, Vector3.up) / NumberOfSkippedFrames
    ConstructCurrentCourse = ConstructCurrentCourse * (1 - EmaNumberForCourse)
            + constructTurnRate * ConstantForFramesPerSecond * EmaNumberForCourse
    
    ConstructMaxTurnRateLongAverage = ConstructMaxTurnRateLongAverage * (1 - EmaNumberForMaxCourse) + math.abs(constructTurnRate * ConstantForFramesPerSecond) * EmaNumberForMaxCourse
    if ConstructMaxTurnRateLongAverage >= ConstructMaxTurnRate then
        ConstructMaxTurnRate = ConstructMaxTurnRate * (1 - EmaNumberForCourse) + ConstructMaxTurnRateLongAverage * EmaNumberForCourse
        ConstructHealthFractionWhenMaxTurnRate = constructHealthFraction
    elseif (constructHealthFraction <= ConstructHealthFractionWhenMaxTurnRate * ChangeInConstructHealthBeforeEvaluation)
            or (ConstructMaxTurnRate > ConstructMaxTurnRateLongAverage * 2) then
        ConstructMaxTurnRate = ConstructMaxTurnRate - ConstructMaxTurnRate * constructHealthFraction / ConstructHealthFractionWhenMaxTurnRate / ConstantForFramesPerSecond * NumberOfSkippedFrames / 10
    end

    if math.abs(ConstructCurrentCourse) > ConstructMaxTurnRate then
        ConstructCurrentCourse = ConstructCurrentCourse * 0.9
    end

    TimeNeededForConstructToReactSafely = math.min(math.max(90 / ConstructMaxTurnRate, 1), MaximumTimeForCoursePrediction)
    
    local newRateOfRotationAndSpeed = {}
    for id, data in pairs(newPositionsAndVectors) do
        if not LastFramePositionsAndVectors[id] then
            RateOfRotationAndSpeed[id] = {Id = data.Id, CurrentCourse = 0, MaxSpeed = 1}
            LastFramePositionsAndVectors[id] = {Id = data.Id, Position = data.Position, Velocity = data.Velocity}
        end        
        newRateOfRotationAndSpeed[id] = {
            Id = data.Id,           
            CurrentCourse = RateOfRotationAndSpeed[id].CurrentCourse * (1 - EmaNumberForCourse)
                    + Vector3.SignedAngle(data.Velocity, LastFramePositionsAndVectors[id].Velocity, Vector3.up) * ConstantForFramesPerSecond * EmaNumberForCourse,
            MaxSpeed = math.max(1, RateOfRotationAndSpeed[id].MaxSpeed * DeclineOfSpeed,
                    RateOfRotationAndSpeed[id].MaxSpeed * (1 - EmaNumber) + data.Velocity.magnitude * EmaNumber)
        }
    end
    RateOfRotationAndSpeed = newRateOfRotationAndSpeed
    LastFrameConstructVelocity = constructVelocity
end


function GetSphericalHalfSize(id)
    if id == ConstantForConstructId then
        return ConstructSphericalHalfSize
    end

    if DimensionsOfEnemies[id] ~= nil then
       -- DBG("DimensionsOfEnemies[id]: ".. DimensionsOfEnemies[id])
        return DimensionsOfEnemies[id]                   
    end    

    if DimensionsOfFriendlies[id] ~= nil then
      --  DBG("DimensionsOfFriendlies[id].MaxSphericalHalfSize: ".. DimensionsOfFriendlies[id].MaxSphericalHalfSize .."  id: "..id)        
        return DimensionsOfFriendlies[id].MaxSphericalHalfSize               
    end

    if id == ConstantForEnemyId then
       -- DBG("Wrong size. id: "..id)
        return FallBackForEnemySphericalHalfSize                                           
    end

    UpdateFriendlySizes()
    if DimensionsOfFriendlies[id] ~= nil then
      --  DBG("New DimensionsOfFriendlies[id].MaxSphericalHalfSize: ".. DimensionsOfFriendlies[id].MaxSphericalHalfSize .."  id: "..id)
        return DimensionsOfFriendlies[id].MaxSphericalHalfSize                   
    end    
    
    DBG("No Size! for  "..id)
    return FallBackForEnemySphericalHalfSize
end


function GetDistanceToObstacleSphere (constructPosition, obstaclePosition, obstacleId) 
    return (constructPosition - obstaclePosition).magnitude - ConstructSphericalHalfSize - GetSphericalHalfSize(obstacleId)
end


function CalculateFlybyDistanceAndTime(constructPosition, constructVelocity, obstaclePosition, obstacleVelocity, obstacleId)   
    local currentSphericalDistance = GetDistanceToObstacleSphere(constructPosition, obstaclePosition, obstacleId)           -- Add id for frd     
    local distanceVector = constructPosition - obstaclePosition    
    local velocityProjection = Vector3.Dot(constructVelocity - obstacleVelocity, distanceVector) / distanceVector.magnitude
    local timeToCloseTheDistance = (currentSphericalDistance / velocityProjection) * -1 
    local predictedPositionForObstacle = obstaclePosition + obstacleVelocity * timeToCloseTheDistance            
    local predictedPositionForConstruct = constructPosition + constructVelocity * timeToCloseTheDistance
    local predictedDistance = GetDistanceToObstacleSphere(predictedPositionForConstruct, predictedPositionForObstacle, obstacleId)
    return predictedDistance, timeToCloseTheDistance, currentSphericalDistance, predictedPositionForConstruct.y
end


function FindMinimalFlybyDistanceAndTime(constructPosition, constructVelocity, positionsAndVectors)
    local minDistancePredicted = ConstantForBigNumber
    local minTimePredicted = ConstantForBigNumber
    local minDistance = ConstantForBigNumber
    local constructNewAltitudeForClosest = 0
    local closestObstacleId = 0 
    
    for id, data in pairs(positionsAndVectors) do
            local distancePrediction, timePrediction, currentSphericalDistance, constructNewAltitude = CalculateFlybyDistanceAndTime(
                                                            constructPosition, constructVelocity,
                                                            data.Position, data.Velocity, data.Id)
        if timePrediction < minTimePredicted and timePrediction > 0 then
            minDistancePredicted = distancePrediction
            minTimePredicted = timePrediction
            constructNewAltitudeForClosest = constructNewAltitude
        end
        if currentSphericalDistance < minDistance then
            minDistance = currentSphericalDistance
            closestObstacleId = id
        end
     --   DBG("FB: id: "..id.." distancePrediction: "..distancePrediction.." timePrediction:"..timePrediction.." currentSphericalDistance: "..currentSphericalDistance)
    end
    return minDistancePredicted, minTimePredicted, minDistance, closestObstacleId, constructNewAltitudeForClosest                  
end


function PredictFutureCircularPosition(travelTime, currentPosition, velocityVector, speed, rateOfTurn, currentCourse)           -- V3 math are FUUUCKING SLOOOOW!
    local timeToChangeCourse = math.abs((currentCourse - rateOfTurn) / rateOfTurn)
    local partialCourseChange = (rateOfTurn * (travelTime / timeToChangeCourse) + currentCourse) / 2

    if travelTime < timeToChangeCourse then
      --  return currentPosition + Quaternion.AngleAxis(medianCourse, Vector3.up) * velocityVector * (travelTime * 0.8)       -- Am i happy with this? 
        return currentPosition + Quaternion.AngleAxis(partialCourseChange, Vector3.up) * velocityVector.normalized * speed * (travelTime * 0.8)
    end
    
    local medianCourse = (rateOfTurn + currentCourse) / 2
    
    travelTime = travelTime - timeToChangeCourse
    local vectorFromStartToCenter = Quaternion(0, 0.70710676908493, 0, 0.70710676908493) * velocityVector.normalized * (speed * 180 / rateOfTurn /  math.pi)
    local vectorFromCenterToPredictionPoint = Quaternion.AngleAxis(rateOfTurn * travelTime, Vector3.up) * (vectorFromStartToCenter * -1)
    return currentPosition + Quaternion.AngleAxis(medianCourse, Vector3.up) * velocityVector * timeToChangeCourse
            + vectorFromStartToCenter + vectorFromCenterToPredictionPoint
end


function CompareSafetyOfManeuversAndChooseDirectionOfTurn (timeNeededToReactSafely, numberOfFrames, constructPosition, constructVelocity, currentPositionsAndVectors)
    local constructSpeed = ConstructCurrentSpeed
    local constructCurrentCourse = ConstructCurrentCourse * -0.7
    local constructHardRightCourse = ConstructMaxTurnRate * 0.7
    local constructHardLeftCourse = ConstructMaxTurnRate * -0.7

   -- DBG("L: "..constructHardLeftCourse.." C: "..constructCurrentCourse.." R: "..constructHardRightCourse)

    local minCurrentDistanceCurrentCourse, minFinalCurrentDistanceCurrentCourse = ConstantForBigNumber, ConstantForBigNumber
    local minCurrentDistanceHardRightCourse, minFinalCurrentDistanceHardRightCourse = ConstantForBigNumber, ConstantForBigNumber
    local minCurrentDistanceHardLeftCourse, minFinalCurrentDistanceHardLeftCourse = ConstantForBigNumber, ConstantForBigNumber

    local averageDistanceCC, averageDistanceHR, averageDistanceHL = 0, 0, 0
    
    for currentFrame = 1, numberOfFrames do
        local timeFrame = timeNeededToReactSafely / numberOfFrames * currentFrame

        local constructPositionCurrentCourse = PredictFutureCircularPosition(
                timeFrame, constructPosition, constructVelocity, constructSpeed, constructCurrentCourse, constructCurrentCourse)
        local constructPositionHardRightCourse = PredictFutureCircularPosition(
                timeFrame, constructPosition, constructVelocity, constructSpeed, constructHardRightCourse, constructCurrentCourse)
        local constructPositionHardLeftCourse = PredictFutureCircularPosition(
                timeFrame, constructPosition, constructVelocity, constructSpeed, constructHardLeftCourse, constructCurrentCourse)

        for id, data in pairs(currentPositionsAndVectors) do
            local currentCourse = Get_TurnRate(id)
            local obstaclePosition = PredictFutureCircularPosition (timeFrame, data.Position, data.Velocity, Get_Speed(id), currentCourse, currentCourse)
            local fakeId = data.Id

            local currentDistanceCurrentCourse = GetDistanceToObstacleSphere(constructPositionCurrentCourse, obstaclePosition, fakeId)
            local currentDistanceHardRightCourse = GetDistanceToObstacleSphere(constructPositionHardRightCourse, obstaclePosition, fakeId)
            local currentDistanceHardLeftCourse = GetDistanceToObstacleSphere(constructPositionHardLeftCourse, obstaclePosition, fakeId)

            averageDistanceCC = averageDistanceCC + currentDistanceCurrentCourse                        -- Ignore by distance
            averageDistanceHR = averageDistanceHR + currentDistanceHardRightCourse
            averageDistanceHL = averageDistanceHL + currentDistanceHardLeftCourse
            
            if currentFrame == numberOfFrames then
                if currentDistanceCurrentCourse < minFinalCurrentDistanceCurrentCourse then
                    minFinalCurrentDistanceCurrentCourse = currentDistanceCurrentCourse
                end
                if currentDistanceHardRightCourse < minFinalCurrentDistanceHardRightCourse then
                    minFinalCurrentDistanceHardRightCourse = currentDistanceHardRightCourse
                end
                if currentDistanceHardLeftCourse < minFinalCurrentDistanceHardLeftCourse then
                    minFinalCurrentDistanceHardLeftCourse = currentDistanceHardLeftCourse
                end
            else
                if currentDistanceCurrentCourse < minCurrentDistanceCurrentCourse then
                    minCurrentDistanceCurrentCourse = currentDistanceCurrentCourse
                end
                if currentDistanceHardRightCourse < minCurrentDistanceHardRightCourse then
                    minCurrentDistanceHardRightCourse = currentDistanceHardRightCourse
                end
                if currentDistanceHardLeftCourse < minCurrentDistanceHardLeftCourse then
                    minCurrentDistanceHardLeftCourse = currentDistanceHardLeftCourse
                end
            end

        end

    end

    averageDistanceCC = averageDistanceCC / numberOfFrames
    averageDistanceHR = averageDistanceHR / numberOfFrames
    averageDistanceHL = averageDistanceHL / numberOfFrames
--[[
    DBG("minCurrentDistanceHardLeftCourse: "..minCurrentDistanceHardLeftCourse
            .." minCurrentDistanceCurrentCourse: "..minCurrentDistanceCurrentCourse
            .." minCurrentDistanceHardRightCourse: "..minCurrentDistanceHardRightCourse)
    DBG("minFinalCurrentDistanceHardLeftCourse: "..minFinalCurrentDistanceHardLeftCourse
            .." minFinalCurrentDistanceCurrentCourse: "..minFinalCurrentDistanceCurrentCourse
            .." minFinalCurrentDistanceHardRightCourse: "..minFinalCurrentDistanceHardRightCourse)
    DBG("averageDistanceHL: "..averageDistanceHL
            .." averageDistanceCC: "..averageDistanceCC
            .." averageDistanceHR: "..averageDistanceHR)

    ]]
    local propulsionRequestForward = PropulsionRequestWhileAvoiding
    local PropulsionRequestReverse = PropulsionRequestToStopOrReverse
    local YawDirectionSign = 1
    if ConstructForwardsVelocityMagnitude < 0 then                                          -- Redo!
        propulsionRequestForward = PropulsionRequestToStopOrReverse
        PropulsionRequestReverse = PropulsionRequestWhileAvoiding
        YawDirectionSign = ChangeToYawDirectionWhileInReverse
    end
    
    if AggressiveForward 
            and minFinalCurrentDistanceCurrentCourse > CurrentSafeDistance and (minCurrentDistanceCurrentCourse > CurrentSafeDistance
            or (minCurrentDistanceCurrentCourse > 0 and averageDistanceCC > averageDistanceHL and averageDistanceCC > averageDistanceHR))
       --     and minCurrentDistanceCurrentCourse > minCurrentDistanceHardLeftCourse and minCurrentDistanceCurrentCourse > minCurrentDistanceHardRightCourse 
    then    
        DBG("It's fine!")
        return 0, 0, 0
    end
    
    if PreferredRight and minFinalCurrentDistanceHardRightCourse > CurrentSafeDistance and minCurrentDistanceHardRightCourse > 0 
        and averageDistanceHR > averageDistanceHL
    then
        DBG("Preferred Right.")
        return PropulsionRequestForYawRight * YawDirectionSign, propulsionRequestForward, 0
    end

    if minFinalCurrentDistanceHardRightCourse > minFinalCurrentDistanceHardLeftCourse and
            minFinalCurrentDistanceHardRightCourse > CurrentSafeDistance and
            minCurrentDistanceHardRightCourse > 0 then
        DBG("Go right. Safe.")
        return PropulsionRequestForYawRight * YawDirectionSign, propulsionRequestForward, 0
    end

    if minFinalCurrentDistanceHardLeftCourse > minFinalCurrentDistanceHardRightCourse and
            minFinalCurrentDistanceHardLeftCourse > CurrentSafeDistance and
            minCurrentDistanceHardLeftCourse > 0 then
        DBG("Go left. Safe.")
        return PropulsionRequestForYawRight * -1 * YawDirectionSign, propulsionRequestForward, 0
    end

    if minFinalCurrentDistanceHardRightCourse < 0 and minFinalCurrentDistanceHardLeftCourse < 0 then
        if minFinalCurrentDistanceHardRightCourse > minFinalCurrentDistanceHardLeftCourse then
        --if minCurrentDistanceHardRightCourse > minCurrentDistanceHardLeftCourse then
            DBG("Right. Unsafe!")
            return PropulsionRequestForYawRight * YawDirectionSign, propulsionRequestForward, 0
        else
            DBG("Left. Unsafe!")
            return PropulsionRequestForYawRight * -1 * YawDirectionSign, propulsionRequestForward, 0  
        end
    end
 
    if minFinalCurrentDistanceHardRightCourse > minFinalCurrentDistanceHardLeftCourse
            and minCurrentDistanceHardRightCourse > minCurrentDistanceHardLeftCourse
    then
        DBG("Right. Unsafe 2!")
        return PropulsionRequestForYawRight * YawDirectionSign, propulsionRequestForward, 0
    end
    if minFinalCurrentDistanceHardLeftCourse > minFinalCurrentDistanceHardRightCourse
            and minCurrentDistanceHardLeftCourse > minCurrentDistanceHardRightCourse
    then    
        DBG("Left. Unsafe 2!")
         return PropulsionRequestForYawRight * -1 * YawDirectionSign, propulsionRequestForward, 0
        
    end

    if  averageDistanceHR > averageDistanceHL
            and minCurrentDistanceHardRightCourse > minCurrentDistanceHardLeftCourse then
        DBG("Right. Unsafe 3 !")
        return PropulsionRequestForYawRight * YawDirectionSign, propulsionRequestForward, 0    
    end
    if averageDistanceHL > averageDistanceHR
            and minCurrentDistanceHardLeftCourse > minCurrentDistanceHardRightCourse then
        DBG("Left. Unsafe 3 !")
        return PropulsionRequestForYawRight * -1 * YawDirectionSign, propulsionRequestForward, 0
    end
    
    if minFinalCurrentDistanceHardRightCourse > minFinalCurrentDistanceHardLeftCourse then
        DBG("Attaque! Right.")
        return PropulsionRequestForYawRight * YawDirectionSign, PropulsionRequestReverse, 0
    else
        DBG("Attaque! Left.")
        return PropulsionRequestForYawRight * -1 * YawDirectionSign, PropulsionRequestReverse, 0
    end

    return PropulsionRequestForYawRight * YawDirectionSign, PropulsionRequestReverse, 0
end


function GetConstructRoll(constructForwardVector, constructUpVector)
    local constructYawRaw = math.atan2(constructForwardVector.z, constructForwardVector.x);
    local constructRoll = math.asin(constructUpVector.x * math.sin(constructYawRaw) - constructUpVector.z * math.cos(constructYawRaw));
    if(constructUpVector.y < 0) then
        if constructRoll < 0 then
            constructRoll = -1 * math.pi - constructRoll
        else
            constructRoll = 1 * math.pi - constructRoll
        end
    end
    return constructRoll * 180 / math.pi * -1  
end


function CompareSafetyOfManeuversAndChooseDirectionOfTurnForPlane(constructPosition, constructVelocity, newPositionsAndVectors, timeToCollision)
    local propulsionRequestForward = PropulsionRequestWhileAvoiding
    local PropulsionRequestReverse = PropulsionRequestToStopOrReverse
    local YawDirectionSign = 1
    if ConstructForwardsVelocityMagnitude < 0 then                                          -- Redo!
        propulsionRequestForward = PropulsionRequestToStopOrReverse
        PropulsionRequestReverse = PropulsionRequestWhileAvoiding
        YawDirectionSign = ChangeToYawDirectionWhileInReverse
    end

   -- DBG("YawDirectionSign: "..YawDirectionSign)
    
    local desiredYaw, desiredForward, desiredPitch = 0, 0, 0

    local constructRightVector = I:GetConstructRightVector()
    local constructUpVector = I:GetConstructUpVector()
    local constructForwardVector = I:GetConstructForwardVector()
    

    local constructRollRounded = Mathf.Round(GetConstructRoll(constructForwardVector, constructUpVector) / 90) * 90
    
    local angleStep = CourseChangeDegreesToLookForSafety    
    local angleStepRemapMultiplierUp, angleStepRemapMultiplierDown, angleStepRemapMultiplierLeft, angleStepRemapMultiplierRight = 1, 1, 1, 1

    if constructRollRounded == 0 then
        angleStepRemapMultiplierUp, angleStepRemapMultiplierDown, angleStepRemapMultiplierLeft, angleStepRemapMultiplierRight
            = -1, DownwardsSafetyFactor, -1 * LeftSafetyFactor, 1
    end
    if constructRollRounded == -90 then
        angleStepRemapMultiplierUp, angleStepRemapMultiplierDown, angleStepRemapMultiplierLeft, angleStepRemapMultiplierRight
        = -1, 1 * LeftSafetyFactor, -1, DownwardsSafetyFactor
    end
    if constructRollRounded == 90 then
        angleStepRemapMultiplierUp, angleStepRemapMultiplierDown, angleStepRemapMultiplierLeft, angleStepRemapMultiplierRight
        = -1 * LeftSafetyFactor, 1, -1 * DownwardsSafetyFactor, 1
    end    
    if constructRollRounded == -180 or constructRollRounded == 180 then
        angleStepRemapMultiplierUp, angleStepRemapMultiplierDown, angleStepRemapMultiplierLeft, angleStepRemapMultiplierRight
        = -1 * DownwardsSafetyFactor, 1, -1, 1 * LeftSafetyFactor
    end
    
    local minDistancePredictedUp, minTimePredictedUp, currentDistanceUp, closestObstacleIdUp, constructNewAltitudeUp
    =  FindMinimalFlybyDistanceAndTime(constructPosition, Quaternion.AngleAxis(angleStep * angleStepRemapMultiplierUp, constructRightVector) * constructVelocity, newPositionsAndVectors)
    local minDistancePredictedDown, minTimePredictedDown, currentDistanceDown, closestObstacleIdDown, constructNewAltitudeDown
    =  FindMinimalFlybyDistanceAndTime(constructPosition, Quaternion.AngleAxis(angleStep * angleStepRemapMultiplierDown, constructRightVector) * constructVelocity, newPositionsAndVectors)
    local minDistancePredictedLeft, minTimePredictedLeft, currentDistanceLeft, closestObstacleIdLeft, constructNewAltitudeLeft
    =  FindMinimalFlybyDistanceAndTime(constructPosition, Quaternion.AngleAxis(angleStep * angleStepRemapMultiplierLeft, constructUpVector) * constructVelocity, newPositionsAndVectors)
    local minDistancePredictedRight, minTimePredictedRight, currentDistanceRight, closestObstacleIdRight, constructNewAltitudeRight
    =  FindMinimalFlybyDistanceAndTime(constructPosition, Quaternion.AngleAxis(angleStep * angleStepRemapMultiplierRight, constructUpVector) * constructVelocity, newPositionsAndVectors)
    
    local MinimumAltitudeForPitchDown = MinimumAltitudeForSubmarinePitchDown
    local MaximumAltitudeForPitchUp = MaximumAltitudeForPlanePitchUp
    if CurrentTypeOfTheCraft == 3 then
        MinimumAltitudeForPitchDown = MinimumAltitudeForPlanePitchDown
        MaximumAltitudeForPitchUp = MaximumAltitudeForPlanePitchUp      
    end
    if CurrentTypeOfTheCraft == 4 then
        MinimumAltitudeForPitchDown = MinimumAltitudeForSubmarinePitchDown
        MaximumAltitudeForPitchUp = MaximumAltitudeForSubmarinePitchUp
    end

    if DisableUpAndDownCourseChange then
        MinimumAltitudeForPitchDown = 10000
        MaximumAltitudeForPitchUp = -10000
        UsePitchAltitudeLimit = true
    end
    
    
    if desiredPitch == 0 then
        if minDistancePredictedDown > minDistancePredictedUp then
            desiredPitch = PropulsionRequestForPitchUp * -1
            DBG("Down.")
            if UsePitchAltitudeLimit
                and ( (constructRollRounded == 0 and constructNewAltitudeDown < MinimumAltitudeForPitchDown)
                    or ((constructRollRounded == -180 or constructRollRounded == 180) and constructNewAltitudeDown > MaximumAltitudeForPitchUp) ) then
                desiredPitch = 0
           --     DBG("Pitch limit.  constructNewAltitudeDown: "..constructNewAltitudeDown)
            end
        else
            desiredPitch = PropulsionRequestForPitchUp
            DBG("Up.")
            if UsePitchAltitudeLimit
                and ( (constructRollRounded == 0 and constructNewAltitudeUp > MaximumAltitudeForPitchUp)
                    or ((constructRollRounded == -180 or constructRollRounded == 180) and constructNewAltitudeUp < MinimumAltitudeForPitchDown) ) then
                desiredPitch = 0
        --        DBG("Pitch limit.  constructNewAltitudeUp: "..constructNewAltitudeUp)
            end
        end
        if minTimePredictedUp < timeToCollision and minTimePredictedDown < timeToCollision then
            desiredForward = PropulsionRequestReverse
       --     DBG("Close U/D.")
        else
            desiredForward = propulsionRequestForward        
        end
    end
    
    if desiredYaw == 0 then
        if minDistancePredictedRight > minDistancePredictedLeft then
            desiredYaw = PropulsionRequestForYawRight * YawDirectionSign
            DBG("Right")
            if UsePitchAltitudeLimit
                and ( (constructRollRounded == 90 and constructNewAltitudeRight > MaximumAltitudeForPitchUp)
                    or (constructRollRounded == -90 and constructNewAltitudeRight < MinimumAltitudeForPitchDown) ) then
                desiredYaw = 0
            --    DBG("Yaw limit.  constructNewAltitudeRight: "..constructNewAltitudeRight)
            end
        else
            desiredYaw = PropulsionRequestForYawRight * YawDirectionSign * -1
            DBG("Left")
            if UsePitchAltitudeLimit
                and ( (constructRollRounded == 90 and constructNewAltitudeLeft < MinimumAltitudeForPitchDown)
                    or (constructRollRounded == -90 and constructNewAltitudeLeft > MaximumAltitudeForPitchUp) ) then
                desiredYaw = 0
           --     DBG("Yaw limit.  constructNewAltitudeLeft: "..constructNewAltitudeLeft)
            end
        end
        if minTimePredictedLeft < timeToCollision and minTimePredictedRight < timeToCollision then
            desiredForward = PropulsionRequestReverse
           -- DBG("Close L/R.")
        else
            desiredForward = propulsionRequestForward
        end
    end
    
    return desiredYaw, desiredForward, desiredPitch
end


function SetPriorityNumberAndCountFriendlies ()
    local result = 0
    local count = 1
    local FriendlyIds = {}
    local constructId = I:GetUniqueId()
    table.insert (FriendlyIds, constructId)
    for i = 0, I:GetFriendlyCount() - 1, 1 do
        table.insert (FriendlyIds, I:GetFriendlyInfo(i).Id)
        count = count + 1
    end
    
    table.sort(FriendlyIds, function(a,b) return a<b end)

    for _, data in pairs(FriendlyIds) do
        if constructId == data then
            break
        end        
        result = result + 1
    end

    PreviousCountForFriendlies = count
    ConstructPriorityNumber = result
end


function ShouldItBeAvoided(constructPosition, position)

    local typeOfEnemy = GetTypeOfUnitFromAltitude (position)

  --  DBG("ShouldItBeAvoided. "..PV(position-constructPosition))

    if (position - constructPosition).magnitude < ObstacleExclusionDistance then
        
        if typeOfEnemy == CurrentTypeOfTheCraft then
            return true
        end
        
        if CurrentTypeOfTheCraft == 2 and ShouldYourSurfaceCraftAvoidPlanes and typeOfEnemy == 3 then
            return true
        end

        if CurrentTypeOfTheCraft == 2 and ShouldYourSurfaceCraftAvoidSubmarines and typeOfEnemy == 4 then
            return true
        end

        if CurrentTypeOfTheCraft == 3 and ShouldYourPlaneAvoidSurfaceCrafts and typeOfEnemy == 2 then
            return true
        end

        if CurrentTypeOfTheCraft == 4 and ShouldYourSubmarineAvoidSurfaceCrafts and typeOfEnemy == 2 then
            return true
        end
    end
    
 --   DBG("ShouldItBeAvoided. false !!")
    
    return false
end


function GetBorderViolationMetric  (constructPosition, constructVelocity)
    local newPosition = constructPosition + constructVelocity * TimeToPredictBorderViolation
    local north = newPosition.z - MapBorderPointZ1
    local south = (newPosition.z - MapBorderPointZ2) * -1
    local west = (newPosition.x - MapBorderPointX1) * -1
    local east = newPosition.x - MapBorderPointX2

  --  DBG("north: "..north.." south: "..south.." west: "..west.." east: "..east)    
    
    return math.max(north, south, west, east)    
end


function CheckForBorderViolation (constructPosition, constructVelocity)
  --  local newPosition = constructPosition + constructVelocity * TimeToPredictBorderViolation

 --   DBG("I:GetConstructYaw(): "..I:GetConstructYaw())
    local currentViolation = GetBorderViolationMetric(constructPosition, constructVelocity)
    
 --   DBG("currentViolation: "..currentViolation)


    if currentViolation>0 then
        local angleStep = CourseChangeDegreesToLookForSafety

       -- local constructRightVector = I:GetConstructRightVector()
      --  local constructUpVector = I:GetConstructUpVector()        
        
        
        local rightTurnViolation = GetBorderViolationMetric(constructPosition, Quaternion.AngleAxis(angleStep --[[ *angleStepRemapMultiplierUp]], Vector3.up) * constructVelocity)
        local leftTurnViolation = GetBorderViolationMetric(constructPosition, Quaternion.AngleAxis(angleStep * -1--[[ *angleStepRemapMultiplierUp]], Vector3.up) * constructVelocity)
        DBG("rightTurnViolation: "..rightTurnViolation.." leftTurnViolation: "..leftTurnViolation)

        local turnDirectionSign = 1
        
        if rightTurnViolation < leftTurnViolation then
            DBG("Turning right from border!")
            turnDirectionSign = 1
        else
            DBG("Turning left from border!")
            turnDirectionSign = -1
        end

        
        local constructUpVector = I:GetConstructUpVector()
        local constructForwardVector = I:GetConstructForwardVector()
        local constructRollRounded = Mathf.Round(GetConstructRoll(constructForwardVector, constructUpVector) / 90) * 90

        if constructRollRounded == 0 then
            return PropulsionRequestForYawRight * turnDirectionSign, 0
        end
        if constructRollRounded == -90 then
            return 0, PropulsionRequestForPitchUp * turnDirectionSign                                       -- check roll sign!
        end
        if constructRollRounded == 90 then
            return 0, PropulsionRequestForPitchUp * turnDirectionSign * -1
        end
        if constructRollRounded == -180 or constructRollRounded == 180 then
            return PropulsionRequestForYawRight * turnDirectionSign * -1, 0
        end
        
    end
    
    return 0, 0
end


function CheckForWorldShift (constructPosition, lastFrameConstructPosition, constructVelocity)
    if (constructPosition - lastFrameConstructPosition).magnitude / (constructVelocity.magnitude * NumberOfSkippedFrames / 40 ) > 100 then
      --  I:LogToHud("World Shift! Xc:" .. Mathf.Round((MapBorderPointX1+MapBorderPointX2)/2).." Zc: "..Mathf.Round((MapBorderPointZ1+MapBorderPointZ2)/2))
        return true
    else    
        return false
    end
end



function FindMapBorderPoints(anyTerrainX, anyTerrainZ, farFarAway)

    function FindBorderLine(lastTerrainPoint, lastSeabedPoint, seabedDepth, direction, otherCoordinate)
        --local lastTerrainPoint-lastSeabedPoint
        --  I:Log("lastTerrainPoint: "..lastTerrainPoint.."  lastSeabedPoint: "..lastSeabedPoint)
        if (lastSeabedPoint - lastTerrainPoint) <= 1 and (lastSeabedPoint - lastTerrainPoint) >= -1 then
            return lastTerrainPoint
        else
            local newPoint = lastTerrainPoint + (lastSeabedPoint - lastTerrainPoint)/2
            local depth = 0
            if direction == "NS" then
                depth = I:GetTerrainAltitudeForPosition(otherCoordinate, 0, newPoint)
            else
                depth = I:GetTerrainAltitudeForPosition(newPoint, 0, otherCoordinate)
            end

            if depth == seabedDepth then
                return FindBorderLine(lastTerrainPoint, newPoint, seabedDepth, direction, otherCoordinate)
            else
                return FindBorderLine(newPoint, lastSeabedPoint, seabedDepth, direction, otherCoordinate)
            end

        end
    end

    local seabedDepth = I:GetTerrainAltitudeForPosition(farFarAway, 0, farFarAway)
  --  I:Log("seabedDepth: "..seabedDepth)
    --[[ I:Log("zE: "..FindBorderLine(anyTerrainX, farFarAway, seabedDepth, "WE", anyTerrainZ))
     I:Log("zW: "..FindBorderLine(anyTerrainX, -farFarAway, seabedDepth, "WE", anyTerrainZ))
     I:Log("zN: "..FindBorderLine(anyTerrainZ, farFarAway, seabedDepth, "NS", anyTerrainX))
     I:Log("zS: "..FindBorderLine(anyTerrainZ, -farFarAway, seabedDepth, "NS", anyTerrainX))
     ]]
    return FindBorderLine(anyTerrainX, -farFarAway, seabedDepth, "WE", anyTerrainZ) + MinimumDistanceFromBorder,
    FindBorderLine(anyTerrainZ, farFarAway, seabedDepth, "NS", anyTerrainX) - MinimumDistanceFromBorder,
    FindBorderLine(anyTerrainX, farFarAway, seabedDepth, "WE", anyTerrainZ) - MinimumDistanceFromBorder,
    FindBorderLine(anyTerrainZ, -farFarAway, seabedDepth, "NS", anyTerrainX) + MinimumDistanceFromBorder

end






function CheckForTerrainAhead (constructPosition, constructVelocity)
   -- local newPosition = constructPosition + constructVelocity * TimeToPredictBorderViolation
    
    local constructForwardVector = I:GetConstructForwardVector()
  

    local altitudeOfTerrainAhead = I:GetTerrainAltitudeForPosition(constructPosition + constructVelocity * TimeToPredictTerrain)
    local altitudeOfTerrainCloseAhead = I:GetTerrainAltitudeForPosition(constructPosition + constructVelocity * 1)  

 --   DBG("constructPosition.y: "..constructPosition.y.."  altitudeOfTerrainAhead: "..altitudeOfTerrainAhead.."  altitudeOfTerrainCloseAhead: "..altitudeOfTerrainCloseAhead)


    if ((altitudeOfTerrainAhead - AltitudeDifferenceToPanic) > constructPosition.y)
            or ((altitudeOfTerrainCloseAhead - AltitudeDifferenceToPanic) > constructPosition.y) then
        
        local angleStep = CourseChangeDegreesToLookForSafety

        local rightTurnTerrainAltitude = I:GetTerrainAltitudeForPosition(constructPosition + Quaternion.AngleAxis(angleStep, Vector3.up) * constructVelocity * TimeToPredictTerrain)
        local leftTurnTerrainAltitude = I:GetTerrainAltitudeForPosition(constructPosition + Quaternion.AngleAxis(angleStep * -1, Vector3.up) * constructVelocity * TimeToPredictTerrain)
        DBG("rightTurnTerrainAltitude: "..rightTurnTerrainAltitude.." leftTurnTerrainAltitude: "..leftTurnTerrainAltitude)

        
        local turnDirectionSign = 1
        local desiredPitch = 0
        
        if SendPitchUpIfTerrainAhead then
            desiredPitch = PropulsionRequestForPitchUp
        end
        
        if rightTurnTerrainAltitude < leftTurnTerrainAltitude then
            DBG("Turning right from terrain!")
            turnDirectionSign = 1
        else
            DBG("Turning left from terrain!")
            turnDirectionSign = -1            
        end


        local constructUpVector = I:GetConstructUpVector()

        local constructRollRounded = Mathf.Round(GetConstructRoll(constructForwardVector, constructUpVector) / 90) * 90

        if constructRollRounded == 0 then
            return PropulsionRequestForYawRight * turnDirectionSign, desiredPitch
        end
        if constructRollRounded == -90 then
            return PropulsionRequestForYawRight * -1, PropulsionRequestForPitchUp * turnDirectionSign                                       -- check roll sign!
        end
        if constructRollRounded == 90 then
            return PropulsionRequestForYawRight, PropulsionRequestForPitchUp * turnDirectionSign * -1
        end
        if constructRollRounded == -180 or constructRollRounded == 180 then
            return PropulsionRequestForYawRight * turnDirectionSign * -1, desiredPitch * -1
        end

    end

    return 0, 0
end



function GetTypeOfUnitFromAltitude(constructPosition)
    local altitude = constructPosition.y
    
 --   DBG("altitude: "..altitude.."  HeightOfMapCenter: "..HeightOfMapCenter.."  AltitudeToBePlane: "..AltitudeToBePlane.."  AltitudeToBeSubmarine: "..AltitudeToBeSubmarine)
    
    if altitude > AltitudeToBePlane + HeightOfMapCenter then
        return 3
    elseif altitude < AltitudeToBeSubmarine then
        return 4    
    else    
        return 2
    end
end


function DetectAndAvoidCollision()


    local constructPosition = I:GetConstructCenterOfMass()
    local constructVelocity = I:GetVelocityVector()
    --constructVelocity.y=0                                                             -- Should it stay or should it go ??

    HasTheWorldMovedOn = CheckForWorldShift(constructPosition, LastFrameConstructPosition, constructVelocity)                       -- remove for borderless maps??

    if TypeOfTheCraft == 1 then
        CurrentTypeOfTheCraft = GetTypeOfUnitFromAltitude (constructPosition)
        UpdateCurrentSafeDistance (CurrentTypeOfTheCraft)
    end

    if ForceUsageOfAlgorithm == "Auto" then
        if CurrentTypeOfTheCraft == 2 and IsItALandMap then
            CurrentAlgorithm = AlgorithmForLandUnit            
        else    
            CurrentAlgorithm = AlgorithmForShip
        end
        if CurrentTypeOfTheCraft == 3 then
            CurrentAlgorithm = AlgorithmForPlane
        end
        if CurrentTypeOfTheCraft == 4 then
            CurrentAlgorithm = AlgorithmForSubmarine
        end        
    end
    
    
 --   DBG("CurrentTypeOfTheCraft: "..CurrentTypeOfTheCraft)

    if HasTheWorldMovedOn and DoAvoidMapBorders then
        MapBorderPointX1, MapBorderPointZ1, MapBorderPointX2, MapBorderPointZ2 = FindMapBorderPoints(constructPosition.x, constructPosition.z, 20000)
    end

    local friendlyCount = I:GetFriendlyCount()
    local enemyCount = I:GetNumberOfTargets(0)

    if (friendlyCount + 1) ~= PreviousCountForFriendlies then
        SetPriorityNumberAndCountFriendlies()        
    end
    
    ConstructForwardsVelocityMagnitude = I:GetForwardsVelocityMagnitude()
    local newPositionsAndVectors = {}                                 
                                                                        
    if DoCheckForCollisionWithFriendlies then
        for i = 0, friendlyCount - 1, 1 do
            local infoForObstacle = I:GetFriendlyInfo(i)
            if ShouldItBeAvoided(constructPosition, infoForObstacle.CenterOfMass) then
                newPositionsAndVectors[infoForObstacle.Id] = {
                    Id = infoForObstacle.Id,
                    Position = infoForObstacle.CenterOfMass,
                    Velocity = infoForObstacle.Velocity
                }
            end
        end
    end

    local enemyType = 0
    if DoCheckForCollisionWithEnemy then
        for i = 0, enemyCount - 1, 1 do
            local infoForObstacle = I:GetTargetInfo(0, i)
            if ShouldItBeAvoided(constructPosition, infoForObstacle.Position) then
                
                enemyType = GetTypeOfUnitFromAltitude (infoForObstacle.Position)
                if enemyType == 2 and IsItALandMap then
                    DimensionsOfEnemies[infoForObstacle.Id] = MaximumSizeOfEnemyLandUnits / 2 
                elseif enemyType == 3 then
                    DimensionsOfEnemies[infoForObstacle.Id] = MaximumSizeOfEnemyPlanes / 2
                elseif enemyType == 4 then
                    DimensionsOfEnemies[infoForObstacle.Id] = MaximumSizeOfEnemySubmarines / 2                    
                else
                    DimensionsOfEnemies[infoForObstacle.Id] = MaximumSizeOfEnemyShips / 2
                end
                
                newPositionsAndVectors[infoForObstacle.Id] = {                                
                   -- Id = ConstantForEnemyId, --infoForObstacle.Id,                           -- Deplorable! 
                    Id = infoForObstacle.Id,
                    Position = infoForObstacle.Position,
                    Velocity = infoForObstacle.Velocity
                }
            end            
        end
    end

    --DBG("Obstacles in play: "..GetLengthOfTable(newPositionsAndVectors))

    UpdateRotationAndSpeed(constructVelocity, newPositionsAndVectors)                                       -- Need some love
    LastFramePositionsAndVectors = newPositionsAndVectors
    LastFrameConstructPosition = constructPosition


    if DoAvoidMapBorders then
        local yawFromBorder, pitchFromBorder = CheckForBorderViolation(constructPosition, constructVelocity)
        if yawFromBorder ~= 0 or pitchFromBorder ~= 0 then                                                           -- reverse?!?
            
            return yawFromBorder, PropulsionRequestWhileAvoiding, pitchFromBorder
        end
    end
    

    if ProbeAheadForTerrain and ((CurrentTypeOfTheCraft ~= 3) or (ProbeForTerrainIfPlane and CurrentTypeOfTheCraft == 3)) then
        local yawFromTerrain, pitchFromTerrain = CheckForTerrainAhead(constructPosition, constructVelocity)
        if yawFromTerrain ~= 0 or pitchFromTerrain ~= 0 then                                                        -- reverse?!?
           -- DBG('Terrain Ahead!')
            return yawFromTerrain, PropulsionRequestWhileAvoiding, pitchFromTerrain
        end      
    end


    local minDistancePredicted, minTimePredicted, currentDistance, closestObstacleId
        =  FindMinimalFlybyDistanceAndTime(constructPosition, constructVelocity, newPositionsAndVectors)
    
    local timeNeededToReactSafely = TimeNeededForConstructToReactSafely * 2
    local distanceNeededToReactSafely = ConstructCurrentSpeed * TimeNeededForConstructToReactSafely * 2                -- wrong !!!
    local numberOfFrames = NumberOfFramesToPredictWith
    DBG("timeNeededToReactSafely: "..timeNeededToReactSafely.." distanceNeededToReactSafely: "..distanceNeededToReactSafely.." ConstructCurrentSpeed: "..ConstructCurrentSpeed)
    DBG("minDistancePredicted: "..minDistancePredicted.."  minTimePredicted: "..minTimePredicted.." currentDistance: "..currentDistance)

    if currentDistance < 0 then    
        local obstacleRelativePosition = constructPosition - newPositionsAndVectors[closestObstacleId].Position
                + newPositionsAndVectors[closestObstacleId].Velocity.normalized * (GetSphericalHalfSize(newPositionsAndVectors[closestObstacleId].Id) * 0.0)
        local signForSide = constructVelocity.x * obstacleRelativePosition.z - constructVelocity.z * obstacleRelativePosition.x
    
        local propulsionRequestForward = PropulsionRequestWhileAvoiding
        local PropulsionRequestReverse = PropulsionRequestToStopOrReverse
        local YawDirectionSign = 1
        if ConstructForwardsVelocityMagnitude < 0 then                                   --And again - Redo!
           -- propulsionRequestForward = PropulsionRequestToStopOrReverse
           -- PropulsionRequestReverse = PropulsionRequestWhileAvoiding                 --                      !!!!
            YawDirectionSign = ChangeToYawDirectionWhileInReverse
        end

        if signForSide > 0 then
            DBG ("All is lost! Left! "..currentDistance.."  signForSide: "..signForSide)
            return PropulsionRequestForYawRight * -1 * YawDirectionSign, PropulsionRequestReverse, 0                            -- Add pitch
        else
            DBG ("All is lost! Right! "..currentDistance.."  signForSide: "..signForSide)
            return PropulsionRequestForYawRight * YawDirectionSign, PropulsionRequestReverse, 0
        end
        
    elseif CurrentAlgorithm == "Big Boy" then

         if (currentDistance < CurrentSafeDistance )
            or (currentDistance < distanceNeededToReactSafely and minTimePredicted > 0 and minTimePredicted < timeNeededToReactSafely)
            or (minDistancePredicted < CurrentSafeDistance and minTimePredicted > 0 and minTimePredicted < timeNeededToReactSafely) then        
  
            return CompareSafetyOfManeuversAndChooseDirectionOfTurn (timeNeededToReactSafely, numberOfFrames, constructPosition, constructVelocity, newPositionsAndVectors)
        
         elseif currentDistance < MinimumDistanceToKeepReversing and DesiredForward == PropulsionRequestToStopOrReverse then 
             
            return DesiredYaw, DesiredForward, 0
             
         end
    else
        if (currentDistance < CurrentSafeDistance )
                or (minTimePredicted < timeNeededToReactSafely / 3 and minDistancePredicted < distanceNeededToReactSafely / 3) then

            return CompareSafetyOfManeuversAndChooseDirectionOfTurnForPlane (constructPosition, constructVelocity, newPositionsAndVectors, minTimePredicted)

        end
    end
    
    DBG ("All good. "..currentDistance) 

    return 0, 0, 0
end


FramesSinceLastControlRequest = 0

function DoStuff (desiredYaw, desiredForward, desiredPitch)
    if TypeOfAiOnTheCraft == 1 or TypeOfAiOnTheCraft == 3 then
        if CounterForDelayBeforeTakingControlFromStandardAI <= 0 then
            
            if desiredYaw ~= 0 or desiredPitch ~= 0 or desiredForward ~= 0 then
                if FramesSinceLastControlRequest == 0 or FramesSinceLastControlRequest >= ConstantForFramesPerSecond then
                    I:TellAiThatWeAreTakingControl()
                    FramesSinceLastControlRequest = NumberOfSkippedFrames
                end
                
                I:RequestControl(0, 0, desiredYaw)
                I:RequestControl(0, 4, desiredPitch)
                I:RequestControl(0, 8, desiredForward)
                
            end
            
        end        
        CounterForDelayBeforeTakingControlFromStandardAI = CounterForDelayBeforeTakingControlFromStandardAI - NumberOfSkippedFrames        
        
    end

    if TypeOfAiOnTheCraft == 2 or TypeOfAiOnTheCraft == 3 then

        if desiredYaw == PropulsionRequestForYawRight * -1 then I:RequestComplexControllerStimulus(CCCForYawLeft) end
        if desiredYaw == PropulsionRequestForYawRight then I:RequestComplexControllerStimulus(CCCForYawRight) end

        if desiredForward == PropulsionRequestWhileAvoiding then I:RequestComplexControllerStimulus(CCCWhileAvoiding) end
        if desiredForward == PropulsionRequestToStopOrReverse then I:RequestComplexControllerStimulus(CCCToStopOrReverse) end

        if desiredPitch == PropulsionRequestForPitchUp then I:RequestComplexControllerStimulus(CCCForPitchUp) end
        if desiredPitch == PropulsionRequestForPitchUp * -1 then I:RequestComplexControllerStimulus(CCCForPitchDown) end
        
    end

    DBG(FrameCounter..": DesiredYaw = "..desiredYaw.." desiredForward: "..desiredForward.."  desiredPitch: "..desiredPitch)
end


function DoInputSanityCheck()
    local msg = ""
    if CurrentSafeDistance < 0 then
        CurrentSafeDistance = 10
        msg = msg .. " CurrentSafeDistance! "
    end
    if MaximumSizeOfEnemyShips < 50 then
        MaximumSizeOfEnemyShips = 50
        msg = msg .. " MaximumSizeOfEnemyShips! "
    end
    if CCCForYawRight == CCCForYawLeft then
        msg = msg .. " CCCForYawRight==CCCForYawLeft - not fixed! "
    end
    if MaximumTimeForCoursePrediction < 0 then
        MaximumTimeForCoursePrediction = 10
        msg = msg .. " MaximumTimeForCoursePrediction! "
    end
    if ConstantForConstructId == ConstantForEnemyId then
        msg = msg .. " Nuts - not fixed! "
    end
    return msg
end

function UpdateFriendlySizes()
    for i = 0, I:GetFriendlyCount() - 1, 1 do
        local FriendlyInfo = I:GetFriendlyInfo(i)
        local friendlySize = FriendlyInfo.PositiveSize - FriendlyInfo.NegativeSize + Vector3(1, 1, 1)
        DimensionsOfFriendlies[FriendlyInfo.Id] = {
            Id = FriendlyInfo.Id,
            BoundingBox = friendlySize,
            MaxSphericalHalfSize = math.max(friendlySize.x, friendlySize.y, friendlySize.z) / 2 + ExtraDistanceForBeingFriendly
        }
    end 
end

function UpdateCurrentSafeDistance (currentTypeOfTheCraft)

    if currentTypeOfTheCraft == 1 or currentTypeOfTheCraft == 2 then
        if IsItALandMap then
            CurrentSafeDistance = SafeDistanceForLandUnits
        else
            CurrentSafeDistance = SafeDistanceForShips
        end
    elseif currentTypeOfTheCraft == 3 then
        CurrentSafeDistance = SafeDistanceForPlanes
    elseif currentTypeOfTheCraft == 4 then
        CurrentSafeDistance = SafeDistanceForSubmarines
    end
    
    
end

function StartupInitialization()
    DoInitializationOnStart = false    
    I:ClearLogs()

    SetPriorityNumberAndCountFriendlies()
    
    if InTheFightWithCornHollio then
        desiredSpeed = 0
        EngageSelfDestruct(true)
    end 
    
    ConstructDimensions = ConstructDimensions + I:GetConstructMaxDimensions() - I:GetConstructMinDimensions()
    ConstructSphericalHalfSize = math.max(ConstructDimensions.x, ConstructDimensions.y, ConstructDimensions.z) / 2

    LastFrameConstructVelocity = I:GetVelocityVector()

    UpdateFriendlySizes()

  --  local msg = DoInputSanityCheck()

    local constructPosition = I:GetConstructPosition()    
    MapBorderPointX1, MapBorderPointZ1, MapBorderPointX2, MapBorderPointZ2 = FindMapBorderPoints(constructPosition.x, constructPosition.z, 20000)
    local mapCenterX = (MapBorderPointX1 + MapBorderPointX2) / 2
    local mapCenterZ = (MapBorderPointZ1 + MapBorderPointZ2) / 2
    
  --  I:LogToHud("mapCenterX: "..mapCenterX.."  mapCenterZ: "..mapCenterZ)
    
    CurrentTypeOfTheCraft = TypeOfTheCraft
    HeightOfMapCenter = ( I:GetTerrainAltitudeForPosition(mapCenterX, 0, 0)
                        + I:GetTerrainAltitudeForPosition(mapCenterX + 500, 0, mapCenterZ + 500)
                        + I:GetTerrainAltitudeForPosition(mapCenterX + 500, 0, mapCenterZ - 500)
                        + I:GetTerrainAltitudeForPosition(mapCenterX - 500, 0, mapCenterZ + 500)
                        + I:GetTerrainAltitudeForPosition(mapCenterX - 500, 0, mapCenterZ - 500) ) / 5
    if HeightOfMapCenter > MinimumTerrainAltitudeToBeLandMap then                                                        
        IsItALandMap = true
    end
    HeightOfMapCenter = math.max(0, HeightOfMapCenter)

    UpdateCurrentSafeDistance (TypeOfTheCraft)
    CurrentTypeOfTheCraft = TypeOfTheCraft

    if ForceUsageOfAlgorithm ~= "Auto" then
        CurrentAlgorithm = ForceUsageOfAlgorithm     
    end
    
    
    if ShowMessageForRunningAndWarnings then
        I:LogToHud("CornBox is running on ".. I:GetBlueprintName().." (Id: ".. I:GetUniqueId().."). "..msg)        
    end
    
end


function IsThisFrameActive(frameCounter, activeCraftsPerFrame, previousCountForFriendlies, constructPriorityNumber)
    local FirstPriorityNumberForThisFrame = frameCounter * activeCraftsPerFrame % previousCountForFriendlies
    local FirstPriorityNumberForNextFrame = (frameCounter + 1) * activeCraftsPerFrame % previousCountForFriendlies

    if (previousCountForFriendlies<activeCraftsPerFrame)
            or (constructPriorityNumber >= FirstPriorityNumberForThisFrame and constructPriorityNumber < (FirstPriorityNumberForThisFrame + activeCraftsPerFrame))
            or (constructPriorityNumber < FirstPriorityNumberForNextFrame and  constructPriorityNumber >= (FirstPriorityNumberForNextFrame - activeCraftsPerFrame)) then
       -- DBG("Run on frame: "..frameCounter)
        NumberOfSkippedFrames = FrameCounter - LastActiveFrame
        LastActiveFrame = FrameCounter
        return true
    end
    return false
end


function IsThisBoxActive()
    --local poll = Mathf.Round(I:GetInput(0, 8)*10)
    local poll = Mathf.Round(I:GetCustomAxis("CornBoxPoll")*10)

    if (poll == 0 and VictoryInThePollForPreviousFrame) or (poll == 1 and VictoryInThePoll) then
        --I:RequestControl(0, 8, 0.1)
        I:RequestCustomAxis("CornBoxPoll", 0.1)
        VictoryInThePollForPreviousFrame = true 
        return true
    end 
    
    if CounterForPollDelay == -99 then
        CounterForPollDelay = math.random(0, 20)
    end
    
    if poll ~= 1 and PollResultForPreviousFrame ~= 1 then
        CounterForPollDelay = CounterForPollDelay - 1
        VictoryInThePoll = false
        VictoryInThePollForPreviousFrame = false
        
        if CounterForPollDelay <= 0 then
            --I:RequestControl(0, 8, 0.1)
            I:RequestCustomAxis("CornBoxPoll", 0.1)
            VictoryInThePoll = true
            CounterForPollDelay = math.random(0, 20)
        end
    end

    PollResultForPreviousFrame = poll    
    return false
end


IntegrationModeCycleCounter = 0
IntegrationModeCurrentStep = 0


function RunIntegrationTest()
    IntegrationModeHudRepeatNumber = (IntegrationTestDuration * 40) / (Mathf.Round((IntegrationTestDuration * 40) / (3*40*2))*2)
    IntegrationModeCycleCounter = IntegrationModeCycleCounter - NumberOfSkippedFrames

    if IntegrationModeCycleCounter <=0 then
        IntegrationModeCurrentStep = IntegrationModeCurrentStep + 1
        IntegrationModeCycleCounter = IntegrationTestDuration * 40
    end
                                                                                        --DesiredYaw, DesiredForward, DesiredPitch = RunIntegrationTest()
    
    local msg = "Integration test for ["..I:GetBlueprintName().."]."
    if IsItALandMap then
        msg = msg.." Land map ("..HeightOfMapCenter.."m)."
    else
        msg = msg.." Water map."       
    end

    local currentTypeOfTheCraft = GetTypeOfUnitFromAltitude(I:GetConstructCenterOfMass())

    if TypeOfTheCraft == 1 then 
        if currentTypeOfTheCraft == 2 then msg = msg.." Type: Surface (Auto)." end
        if currentTypeOfTheCraft == 3 then msg = msg.." Type: Plane (Auto)." end
        if currentTypeOfTheCraft == 4 then msg = msg.." Type: Submarine (Auto)." end        
    elseif TypeOfTheCraft == currentTypeOfTheCraft then
        if currentTypeOfTheCraft == 2 then msg = msg.." Type: Surface." end
        if currentTypeOfTheCraft == 3 then msg = msg.." Type: Plane." end
        if currentTypeOfTheCraft == 4 then msg = msg.." Type: Submarine." end
    else

        if TypeOfTheCraft == 2 then msg = msg.." Type: Surface" end
        if TypeOfTheCraft == 3 then msg = msg.." Type: Plane" end
        if TypeOfTheCraft == 4 then msg = msg.." Type: Submarine" end

        if currentTypeOfTheCraft == 2 then msg = msg..", expected: Surface!" end
        if currentTypeOfTheCraft == 3 then msg = msg..", expected: Plane!" end
        if currentTypeOfTheCraft == 4 then msg = msg..", expected: Submarine!" end
        
    end

    if IntegrationModeCurrentStep > 10 then
        IntegrationModeCurrentStep = 1
    end

    if IntegrationModeCurrentStep == 1 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." Forward and Yaw right.")
        end
        return PropulsionRequestForYawRight, PropulsionRequestWhileAvoiding, 0
    elseif IntegrationModeCurrentStep == 2 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." CornBox off.")
        end
        return 0, 0, 0
    elseif IntegrationModeCurrentStep == 3 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." Forward and Yaw left.")
        end
        return PropulsionRequestForYawRight * -1, PropulsionRequestWhileAvoiding, 0
    elseif IntegrationModeCurrentStep == 4 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." CornBox off.")
        end
        return 0, 0, 0
    elseif IntegrationModeCurrentStep == 5 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." Forward and Pitch up.")
        end
        return 0, PropulsionRequestWhileAvoiding, PropulsionRequestForPitchUp
    elseif IntegrationModeCurrentStep == 6 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." CornBox off.")
        end
        return 0, 0, 0
    elseif IntegrationModeCurrentStep == 7 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." Forward and Pitch down.")
        end
        return 0, PropulsionRequestWhileAvoiding, PropulsionRequestForPitchUp * -1
    elseif IntegrationModeCurrentStep == 8 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." CornBox off.")
        end
        return 0, 0, 0
    elseif IntegrationModeCurrentStep == 9 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." Forward slow or stop or reverse.")
        end
        return 0, PropulsionRequestToStopOrReverse, 0        
    elseif IntegrationModeCurrentStep == 10 then
        if IntegrationModeCycleCounter % IntegrationModeHudRepeatNumber == 0 then
            I:LogToHud(msg.." CornBox off.")
        end
        return 0, 0, 0
    end
    
end



function Update(ILocal)
    if StartupDelay <= 0 then
        I=ILocal
        I:ClearLogs()

        local activeFrame = IsThisFrameActive(FrameCounter, ActiveCraftsPerFrame, PreviousCountForFriendlies, ConstructPriorityNumber)
    --    DBG("FrameCounter: "..FrameCounter.."  activeFrame: "..tostring(activeFrame))

        local successForPoll, activeBox = pcall(IsThisBoxActive)
        if not successForPoll then
          --  DBG("Unsuccessful poll.")
            activeBox = true
        end
        --local activeBox = IsThisBoxActive()
     --   DBG("FrameCounter: "..FrameCounter.."  successForPoll: "..tostring(successForPoll).."  activeBox: "..tostring(activeBox))



       -- DBG("GTF: "..I:GetGameTime()/0.025)



        if activeFrame and activeBox then
            local success = false
            
            if DoInitializationOnStart then                         -- add support for new spawns and test for sanity
                StartupInitialization()                                 -- And where are missing friendly size come from?
            end

            if IntegrationTestDuration == 0 then
                success, DesiredYaw, DesiredForward, DesiredPitch = pcall(DetectAndAvoidCollision)
                --success = true  DesiredYaw, DesiredForward, DesiredPitch = DetectAndAvoidCollision()
            else
                success = true
                DesiredYaw, DesiredForward, DesiredPitch = RunIntegrationTest()
            end
                            

            if not success or DesiredYaw == nil or DesiredForward == nil or DesiredPitch == nil then
                DBG("!!Error!!")
                DesiredYaw = 0
                DesiredForward = 0
                DesiredPitch = 0
            end
        else
            DBG("Skipping of the frame. FrameCounter: "..FrameCounter.."  activeFrame: "..tostring(activeFrame).."  activeBox: "..tostring(activeBox))
        end

        if DesiredYaw ~= 0 or DesiredForward ~= 0 or DesiredPitch ~= 0 then
            DoStuff(DesiredYaw, DesiredForward, DesiredPitch)
        else
            CounterForDelayBeforeTakingControlFromStandardAI = DelayBeforeTakingControlFromStandardAI
            DBG(FrameCounter..": No collision to avoid.")
        end
        FramesSinceLastControlRequest = FramesSinceLastControlRequest + NumberOfSkippedFrames
    else
        StartupDelay = StartupDelay - 1
    end
    FrameCounter = FrameCounter + 1
end


function DBG(string)
    I:Log(string)
end


function PV(v)
    return " x: "..v.x.."  y: "..v.y.."  z: "..v.z.."   mg: "..v.magnitude
end


function GetLengthOfTable(table)
    local count = 0
    for _ in pairs(table) do
        count = count + 1
    end
    return count
end


function Get_Speed (id)
    return RateOfRotationAndSpeed[id].MaxSpeed
end                                                                         -- Kill it?
function Get_TurnRate (id)
    return RateOfRotationAndSpeed[id].CurrentCourse
end

